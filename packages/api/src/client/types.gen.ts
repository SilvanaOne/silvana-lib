// This file is auto-generated by @hey-api/openapi-ts

export type TokenInfoRequestParams = {
    /**
     * The address of the token contract.
     */
    tokenAddress: string;
};

export type TokenSymbolAndAdmin = {
    /**
     * The address of the token contract.
     */
    tokenAddress: string;
    /**
     * The address of the admin contract.
     */
    adminContractAddress: string;
    /**
     * The address of the administrator.
     */
    adminAddress: string;
    /**
     * The symbol of the token.
     */
    tokenSymbol: string;
};

export type BalanceRequestParams = {
    /**
     * The address of the token contract (optional).
     */
    tokenAddress?: string;
    /**
     * The token ID (optional).
     */
    tokenId?: string;
    /**
     * The Mina address for which to retrieve the balance.
     */
    address: string;
};

export type BalanceResponse = {
    /**
     * The address of the token contract (optional).
     */
    tokenAddress?: string;
    /**
     * The token ID (optional).
     */
    tokenId?: string;
    /**
     * The Mina address for which the balance was requested.
     */
    address: string;
    /**
     * The balance of the token for the specified address.
     */
    balance?: number;
    /**
     * Indicates whether the account exists.
     */
    hasAccount?: boolean;
};

export type ErrorResponse = {
    /**
     * Error message detailing the issue.
     */
    error?: string;
};

export type JobId = {
    /**
     * The job ID returned by the `/prove` endpoint.
     */
    jobId: string;
};

export type JobResults = {
    /**
     * Indicates whether the job was successful.
     */
    success?: boolean;
    /**
     * The current status of the job.
     */
    jobStatus?: 'created' | 'started' | 'finished' | 'failed' | 'used' | 'restarted';
    /**
     * Error message if the job failed.
     */
    error?: string;
    /**
     * Results for each transaction in the job.
     */
    results?: Array<JobResult>;
};

export type JobResult = {
    /**
     * Indicates whether the proof generation for this transaction was successful.
     */
    success: boolean;
    /**
     * Error message if proof generation failed for this transaction.
     */
    error?: string;
    /**
     * The transaction data.
     */
    tx?: string;
    /**
     * The status of the transaction.
     */
    status?: string;
    /**
     * The transaction hash if broadcasted.
     */
    hash?: string;
};

export type SendTransactionParams = {
    /**
     * The transaction to send.
     */
    transaction: string;
};

export type SendTransactionReply = {
    /**
     * The transaction hash if successful.
     */
    hash?: string;
    /**
     * The status of the transaction.
     */
    status?: string;
    /**
     * Whether the transaction was sent to the network.
     */
    success: boolean;
    /**
     * Error details if the transaction failed.
     */
    error?: {
        [key: string]: unknown;
    };
};

export type TransactionStatusParams = {
    /**
     * The transaction hash to check the status of.
     */
    hash: string;
};

export type TransactionStatus = {
    /**
     * The transaction hash.
     */
    hash?: string;
    /**
     * The status of the transaction.
     */
    status?: 'pending' | 'applied' | 'failed' | 'unknown';
    /**
     * The transaction hash.
     */
    error?: string;
    /**
     * The details of the transaction.
     */
    details?: {
        /**
         * The height of the block containing the transaction.
         */
        blockHeight?: number;
        /**
         * The state hash of the block.
         */
        stateHash?: string;
        /**
         * The status of the block.
         */
        blockStatus?: string;
        /**
         * The timestamp of the block.
         */
        timestamp?: number;
        /**
         * The transaction hash.
         */
        txHash?: string;
        /**
         * The status of the transaction in the block.
         */
        txStatus?: string;
    };
};

export type TxStatus = {
    /**
     * The height of the block containing the transaction.
     */
    blockHeight?: number;
    /**
     * The state hash of the block.
     */
    stateHash?: string;
    /**
     * The status of the block.
     */
    blockStatus?: string;
    /**
     * The timestamp of the block.
     */
    timestamp?: number;
    /**
     * The transaction hash.
     */
    txHash?: string;
    /**
     * The status of the transaction in the block.
     */
    txStatus?: string;
};

export type FaucetParams = {
    /**
     * The Mina address (public key) to receive the test tokens.
     */
    address: string;
};

export type FaucetResponse = {
    /**
     * Indicates whether the faucet request was successful.
     */
    success?: boolean;
    /**
     * The transaction hash of the faucet transfer if successful.
     */
    hash?: string;
    /**
     * Error message if the request failed.
     */
    error?: string;
};

export type NftRequestParams = {
    /**
     * Always set to this contract address for Mina NFT V2.
     */
    contractAddress: string;
    /**
     * The unique NFT address.
     */
    nftAddress: string;
};

export type NftRequestAnswer = {
    contractAddress?: string;
    nftAddress?: string;
    tokenId?: string;
    tokenSymbol?: string;
    contractUri?: string;
    name?: string;
    metadataRoot?: {
        data?: string;
        kind?: string;
    };
    storage?: string;
    owner?: string;
    price?: number;
    version?: number;
    metadata?: {
        [key: string]: unknown;
    };
    algolia?: {
        [key: string]: unknown;
    };
};

export type TokenTransactionType = 'token:launch' | 'token:mint' | 'token:burn' | 'token:redeem' | 'token:transfer' | 'token:bid:create' | 'token:offer:create' | 'token:offer:buy' | 'token:bid:sell' | 'token:airdrop' | 'token:bid:withdraw' | 'token:offer:withdraw' | 'token:bid:whitelist' | 'token:offer:whitelist' | 'token:admin:whitelist';

export type NftTransactionType = 'nft:launch' | 'nft:mint' | 'nft:transfer';

export type TokenTransactionBaseParams = {
    /**
     * Type of the token transaction.
     */
    txType?: TokenTransactionType;
    /**
     * Optional. The address of the token contract.
     */
    tokenAddress?: string;
    /**
     * The address (public key) of the sender.
     */
    sender: string;
    /**
     * The private key of the sender. It is NOT recommended to use this field. Please use the `sender` field instead. Use this field at your own risk and only if you know what you are doing and do not have access to mina-signer or wallet to get the signature.
     */
    senderPrivateKey?: string;
    /**
     * Optional. The nonce for the transaction.
     */
    nonce?: number;
    /**
     * Optional. A memo for the transaction.
     */
    memo?: string;
    /**
     * Optional. The developer fee for the transaction.
     */
    developerFee?: number;
};

export type NftTransactionBaseParams = {
    /**
     * Type of the NFT transaction.
     */
    txType?: NftTransactionType;
    /**
     * Optional. The address of the NFT collection.
     */
    collectionAddress?: string;
    /**
     * The address (public key) of the sender.
     */
    sender: string;
    /**
     * The private key of the sender. It is NOT recommended to use this field. Please use the `sender` field instead. Use this field at your own risk and only if you know what you are doing and do not have access to mina-signer or wallet to get the signature.
     */
    senderPrivateKey?: string;
    /**
     * Optional. The nonce for the transaction.
     */
    nonce?: number;
    /**
     * Optional. A memo for the transaction.
     */
    memo?: string;
    /**
     * Optional. The developer fee for the transaction.
     */
    developerFee?: number;
};

export type DeployedTokenTransactionBaseParams = TokenTransactionBaseParams & {
    /**
     * The address of the token contract.
     */
    tokenAddress: string;
};

export type DeployedNftCollectionTransactionBaseParams = NftTransactionBaseParams & {
    /**
     * The address of the NFT collection.
     */
    collectionAddress: string;
};

export type LaunchTokenTransactionBaseParams = TokenTransactionBaseParams & {
    /**
     * Must be "token:launch"
     */
    txType?: 'token:launch';
    /**
     * The type of admin contract to use.
     */
    adminContract: 'standard' | 'advanced' | 'bondingCurve';
    /**
     * The symbol of the token.
     */
    symbol: string;
    /**
     * Optional. The number of decimal places for the token.
     */
    decimals?: number;
    /**
     * URI or token info object containing metadata.
     */
    uri: string | TokenInfo;
    /**
     * Optional. The address of the token contract.
     */
    tokenAddress?: string;
    /**
     * Optional. The address of the admin contract.
     */
    adminContractAddress?: string;
    /**
     * Optional. Private key for the token contract.
     */
    tokenContractPrivateKey?: string;
    /**
     * Optional. Private key for the admin contract.
     */
    adminContractPrivateKey?: string;
};

export type CollectionData = {
    /**
     * The royalty fee percentage (e.g., 1000 = 1%, 100 = 0.1%, 10000 = 10%, 100000 = 100%)
     */
    royaltyFee?: number;
    /**
     * The transfer fee amount
     */
    transferFee?: number;
    /**
     * If true, transferring NFTs requires approval from the admin contract
     */
    requireTransferApproval?: boolean;
    /**
     * If true, the minting is stopped and cannot be resumed
     */
    mintingIsLimited?: boolean;
    /**
     * Indicates whether the collection is currently paused
     */
    isPaused?: boolean;
};

export type NftMetadata = {
    /**
     * The name of the NFT
     */
    name: string;
    /**
     * The image URL or IPFS hash associated with the NFT
     */
    image: string;
    /**
     * Optional description of the NFT
     */
    description?: string;
    /**
     * Optional banner image URL or IPFS hash. Required for Collection Master NFT.
     */
    banner?: string;
    traits?: Array<{
        /**
         * The trait key/name
         */
        key: string;
        /**
         * The type of the trait value
         */
        type: 'string' | 'text' | 'image' | 'url' | 'field' | 'number' | 'address' | 'map' | 'tree';
        /**
         * The trait value, can be a string or complex object depending on type
         */
        value: string | {
            [key: string]: unknown;
        };
        /**
         * Optional flag indicating if this trait is private
         */
        isPrivate?: boolean;
    }>;
};

export type NftData = {
    /**
     * The public key of the owner of the NFT
     */
    owner: string;
    /**
     * The public key of the approved address of the NFT
     */
    approved?: string;
    /**
     * The version number of the NFT state
     */
    version?: number;
    /**
     * The unique identifier of the NFT within the collection. A bigint encoded as a string.
     */
    id?: string;
    /**
     * Determines whether the NFT's ownership can be changed via a zero-knowledge proof (readonly)
     */
    canChangeOwnerByProof?: boolean;
    /**
     * Specifies if the NFT's ownership can be transferred (readonly)
     */
    canTransfer?: boolean;
    /**
     * Specifies if the NFT's approved address can be changed (readonly)
     */
    canApprove?: boolean;
    /**
     * Indicates whether the NFT's metadata can be updated (readonly)
     */
    canChangeMetadata?: boolean;
    /**
     * Determines whether the storage associated with the NFT can be altered (readonly)
     */
    canChangeStorage?: boolean;
    /**
     * Specifies if the name of the NFT can be changed (readonly)
     */
    canChangeName?: boolean;
    /**
     * Indicates whether the verification key hash for the metadata can be changed (readonly)
     */
    canChangeMetadataVerificationKeyHash?: boolean;
    /**
     * Specifies if the NFT contract can be paused, preventing certain operations (readonly)
     */
    canPause?: boolean;
    /**
     * Indicates whether the NFT contract is currently paused
     */
    isPaused?: boolean;
    /**
     * Determines whether the owner's authorization is required to upgrade the NFT's verification key (readonly)
     */
    requireOwnerAuthorizationToUpgrade?: boolean;
};

export type NftMintParams = {
    /**
     * The name of the NFT
     */
    name: string;
    /**
     * The address of the NFT contract
     */
    address?: string;
    /**
     * The private key of the NFT contract
     */
    addressPrivateKey?: string;
    /**
     * The token ID of the NFT
     */
    tokenId?: number;
    /**
     * The data associated with the NFT, including owner, approved, version, id, permissions and flags
     */
    data: NftData;
    /**
     * The fee associated with minting the NFT
     */
    fee?: number;
    /**
     * The metadata associated with the NFT, Field as a string or NftMetadata object
     */
    metadata: string | NftMetadata;
    /**
     * The off-chain storage information (e.g., IPFS hash)
     */
    storage?: string;
    /**
     * The hash of the verification key used for metadata proofs, Field as a string
     */
    metadataVerificationKeyHash?: string;
    /**
     * The expiry time slot for minting the NFT
     */
    expiry?: number;
};

export type LaunchNftCollectionTransactionBaseParams = NftTransactionBaseParams & {
    /**
     * Must be "nft:launch"
     */
    txType?: 'nft:launch';
    /**
     * The type of admin contract to use. Default is "standard".
     */
    adminContract?: 'standard' | 'advanced';
    /**
     * The symbol of the NFT collection. Use NFT as a default value.
     */
    symbol?: string;
    /**
     * The URL of the NFT collection.
     */
    url?: string;
    /**
     * The name of the NFT collection.
     */
    collectionName: string;
    /**
     * The creator of the NFT collection. Should be the public key of the creator starting with B62.
     */
    creator?: string;
    /**
     * The base URL of the NFT collection, can be 'ipfs' or url with or without `https://`. Default is 'ipfs'.
     */
    baseURL?: string;
    collectionData?: CollectionData;
    masterNFT: NftMintParams;
    /**
     * Optional. The address of the    collection.
     */
    collectionAddress?: string;
    /**
     * Optional. The address of the admin contract.
     */
    adminContractAddress?: string;
    /**
     * Optional. Private key for the collection contract.
     */
    collectionContractPrivateKey?: string;
    /**
     * Optional. Private key for the admin contract.
     */
    adminContractPrivateKey?: string;
};

export type TokenMintTransactionParams = DeployedTokenTransactionBaseParams & {
    /**
     * Must be "token:mint"
     */
    txType?: 'token:mint';
    /**
     * The address to which tokens are to be minted.
     */
    to: string;
    /**
     * The amount of tokens to mint.
     */
    amount: number;
    /**
     * The price of the token in the bonding curve.
     */
    price?: number;
};

export type NftMintTransactionParams = DeployedNftCollectionTransactionBaseParams & {
    /**
     * Must be "nft:mint"
     */
    txType: 'nft:mint';
    nftMintParams: NftMintParams;
};

export type TokenBurnTransactionParams = DeployedTokenTransactionBaseParams & {
    /**
     * Must be "token:burn"
     */
    txType?: 'token:burn';
    /**
     * The address from which tokens are to be burned.
     */
    from: string;
    /**
     * The amount of tokens to burn.
     */
    amount: number;
};

export type TokenRedeemTransactionParams = DeployedTokenTransactionBaseParams & {
    /**
     * Must be "token:redeem"
     */
    txType?: 'token:redeem';
    /**
     * The amount of tokens to redeem.
     */
    amount: number;
    /**
     * The minimum price of the tokens to be redeemed.
     */
    price: number;
    /**
     * The maximum slippage allowed for the redemption, default is 50 (5%).
     */
    slippage?: number;
};

export type TokenTransferTransactionParams = DeployedTokenTransactionBaseParams & {
    /**
     * Must be "token:transfer"
     */
    txType?: 'token:transfer';
    /**
     * The address to which tokens are to be transferred.
     */
    to: string;
    /**
     * The amount of tokens to transfer.
     */
    amount: number;
};

export type TokenAirdropTransactionParams = DeployedTokenTransactionBaseParams & {
    /**
     * Must be "token:airdrop"
     */
    txType?: 'token:airdrop';
    /**
     * List of recipients and amounts for the airdrop
     */
    recipients: Array<{
        /**
         * The recipient's address
         */
        address: string;
        /**
         * The amount to airdrop
         */
        amount: number;
        /**
         * Optional memo for this recipient
         */
        memo?: string;
    }>;
};

export type TokenBidTransactionParams = DeployedTokenTransactionBaseParams & {
    /**
     * Must be "token:bid:create"
     */
    txType?: 'token:bid:create';
    /**
     * Optional. The private key for bidding.
     */
    bidPrivateKey?: string;
    /**
     * Optional. The address for bidding.
     */
    bidAddress?: string;
    /**
     * The amount to bid.
     */
    amount: number;
    /**
     * The price to bid.
     */
    price: number;
    whitelist?: Whitelist;
};

export type TokenOfferTransactionParams = DeployedTokenTransactionBaseParams & {
    /**
     * Must be "token:offer:create"
     */
    txType?: 'token:offer:create';
    /**
     * Optional. The private key for offering.
     */
    offerPrivateKey?: string;
    /**
     * Optional. The address for offering.
     */
    offerAddress?: string;
    /**
     * The amount to offer.
     */
    amount: number;
    /**
     * The price to offer.
     */
    price: number;
    whitelist?: Whitelist;
};

export type TokenBuyTransactionParams = DeployedTokenTransactionBaseParams & {
    /**
     * Must be "token:offer:buy"
     */
    txType?: 'token:offer:buy';
    /**
     * The address of the offer to buy from.
     */
    offerAddress: string;
    /**
     * The amount of tokens to buy.
     */
    amount: number;
};

export type TokenSellTransactionParams = DeployedTokenTransactionBaseParams & {
    /**
     * Must be "token:bid:sell"
     */
    txType?: 'token:bid:sell';
    /**
     * The address of the bid to sell to.
     */
    bidAddress: string;
    /**
     * The amount of tokens to sell.
     */
    amount: number;
};

export type TokenWithdrawBidTransactionParams = DeployedTokenTransactionBaseParams & {
    /**
     * Must be "token:bid:withdraw"
     */
    txType?: 'token:bid:withdraw';
    /**
     * The address of the bid to withdraw from.
     */
    bidAddress: string;
    /**
     * The amount to withdraw from the bid.
     */
    amount: number;
};

export type TokenWithdrawOfferTransactionParams = DeployedTokenTransactionBaseParams & {
    /**
     * Must be "token:offer:withdraw"
     */
    txType?: 'token:offer:withdraw';
    /**
     * The address of the offer to withdraw from.
     */
    offerAddress: string;
    /**
     * The amount to withdraw from the offer.
     */
    amount: number;
};

export type TokenUpdateBidWhitelistTransactionParams = DeployedTokenTransactionBaseParams & {
    /**
     * Must be "token:bid:whitelist"
     */
    txType?: 'token:bid:whitelist';
    /**
     * The address of the bid to update whitelist for.
     */
    bidAddress: string;
    /**
     * Either a list of whitelisted addresses with optional amounts, or a string representing a whitelist contract address
     */
    whitelist: Whitelist;
};

export type TokenUpdateOfferWhitelistTransactionParams = DeployedTokenTransactionBaseParams & {
    /**
     * Must be "token:offer:whitelist"
     */
    txType?: 'token:offer:whitelist';
    /**
     * The address of the offer to update whitelist for.
     */
    offerAddress: string;
    /**
     * Either a list of whitelisted addresses with optional amounts, or a string representing a whitelist contract address
     */
    whitelist: Whitelist;
};

export type TokenUpdateAdminWhitelistTransactionParams = DeployedTokenTransactionBaseParams & {
    /**
     * Must be "token:admin:whitelist"
     */
    txType?: 'token:admin:whitelist';
    /**
     * The address of the admin to update whitelist for.
     */
    adminAddress: string;
    /**
     * Either a list of whitelisted addresses with optional amounts, or a string representing a whitelist contract address
     */
    whitelist: Whitelist;
};

export type LaunchTokenStandardAdminParams = LaunchTokenTransactionBaseParams & {
    /**
     * Must be "standard" for standard admin contract.
     */
    adminContract: 'standard';
};

export type LaunchNftCollectionStandardAdminParams = LaunchNftCollectionTransactionBaseParams & {
    /**
     * Must be "standard" for standard admin contract.
     */
    adminContract: 'standard';
};

export type LaunchTokenAdvancedAdminParams = LaunchTokenTransactionBaseParams & {
    /**
     * Must be "advanced" for advanced admin contract.
     */
    adminContract: 'advanced';
    /**
     * Specifies who can mint tokens.
     */
    canMint: 'whitelist' | 'anyone';
    /**
     * Optional. Whether admin signature is required for minting.
     */
    requireAdminSignatureForMint?: boolean;
    /**
     * Optional. List of whitelisted addresses with optional amounts, or a string.
     */
    whitelist?: Whitelist;
    /**
     * Optional. Maximum total supply. Uses UInt64.MAXINT() if not provided.
     */
    totalSupply?: number;
};

export type AdvancedNftCollectionAdminData = {
    /**
     * Indicates whether the contract can be paused
     */
    canPause?: boolean;
    /**
     * Indicates whether the contract is currently paused
     */
    isPaused?: boolean;
    /**
     * Indicates whether the contract can change the royalty fee
     */
    allowChangeRoyalty?: boolean;
    /**
     * Indicates whether the contract can change the transfer fee
     */
    allowChangeTransferFee?: boolean;
    /**
     * Indicates whether the contract can change the base URI
     */
    allowChangeBaseUri?: boolean;
    /**
     * Indicates whether the contract can change the creator
     */
    allowChangeCreator?: boolean;
    /**
     * Indicates whether the contract can change the admin
     */
    allowChangeAdmin?: boolean;
    /**
     * Indicates whether the contract can change the name
     */
    allowChangeName?: boolean;
};

export type LaunchNftCollectionAdvancedAdminParams = LaunchNftCollectionTransactionBaseParams & {
    /**
     * Must be "advanced" for advanced admin contract.
     */
    adminContract: 'advanced';
    /**
     * The address of the upgrade authority contract
     */
    upgradeAuthority: string;
    /**
     * The admin data for the NFT collection
     */
    adminData?: AdvancedNftCollectionAdminData;
    /**
     * Optional. List of whitelisted addresses with optional amounts, or a string.
     */
    whitelist?: Whitelist;
};

export type LaunchTokenBondingCurveAdminParams = LaunchTokenTransactionBaseParams & {
    /**
     * Must be "bondingCurve" for bonding curve admin contract.
     */
    adminContract: 'bondingCurve';
};

export type TokenInfo = {
    /**
     * The symbol of the token.
     */
    symbol?: string;
    /**
     * Optional. The name of the token.
     */
    name?: string;
    /**
     * Optional. Description of the token.
     */
    description?: string;
    /**
     * Optional. URL of the token image.
     */
    imageUrl?: string;
    /**
     * Optional. Base64-encoded image data (max 1 MB).
     */
    imageBase64?: string;
    /**
     * Optional. Twitter handle associated with the token.
     */
    twitter?: string;
    /**
     * Optional. Discord link associated with the token.
     */
    discord?: string;
    /**
     * Optional. Telegram link associated with the token.
     */
    telegram?: string;
    /**
     * Optional. Instagram handle associated with the token.
     */
    instagram?: string;
    /**
     * Optional. Facebook page associated with the token.
     */
    facebook?: string;
    /**
     * Optional. Official website of the token.
     */
    website?: string;
    /**
     * Optional. Code for the token contract.
     */
    tokenContractCode?: string;
    /**
     * Optional. Code for the admin contracts.
     */
    adminContractsCode?: Array<string>;
};

export type TransactionPayloads = {
    /**
     * The address initiating the transaction.
     */
    sender: string;
    /**
     * The nonce for the transaction.
     */
    nonce: number;
    /**
     * A memo for the transaction.
     */
    memo: string;
    /**
     * The fee for the transaction.
     */
    fee: number;
    walletPayload: {
        /**
         * The nonce for the transaction.
         */
        nonce?: number;
        /**
         * The transaction data.
         */
        transaction?: string;
        /**
         * Indicates if only signature is needed.
         */
        onlySign?: boolean;
        feePayer?: {
            /**
             * The fee for the transaction.
             */
            fee?: number;
            /**
             * A memo for the transaction.
             */
            memo?: string;
        };
    };
    minaSignerPayload: {
        /**
         * The zkApp command data.
         */
        zkappCommand: {
            [key: string]: unknown;
        };
        feePayer: {
            /**
             * The fee payer's address.
             */
            feePayer?: string;
            /**
             * The fee for the transaction.
             */
            fee?: number;
            /**
             * The nonce for the transaction.
             */
            nonce?: number;
            /**
             * A memo for the transaction.
             */
            memo?: string;
        };
    };
    /**
     * The payload for the prover.
     */
    proverPayload: string;
    /**
     * The signed data for the transaction.
     */
    signedData: string;
    /**
     * The raw transaction data.
     */
    transaction: string;
    /**
     * Optional. Whether to broadcast the transaction after proving.
     */
    sendTransaction?: boolean;
};

export type TokenTransactionParams = LaunchTokenStandardAdminParams | LaunchTokenAdvancedAdminParams | TokenMintTransactionParams | TokenBurnTransactionParams | TokenRedeemTransactionParams | TokenTransferTransactionParams | TokenAirdropTransactionParams | TokenOfferTransactionParams | TokenBidTransactionParams | TokenBuyTransactionParams | TokenSellTransactionParams | TokenWithdrawBidTransactionParams | TokenWithdrawOfferTransactionParams | TokenUpdateBidWhitelistTransactionParams | TokenUpdateOfferWhitelistTransactionParams | TokenUpdateAdminWhitelistTransactionParams;

export type NftTransactionParams = LaunchNftCollectionStandardAdminParams | LaunchNftCollectionAdvancedAdminParams | NftMintTransactionParams;

export type TokenTransaction = TransactionPayloads & {
    /**
     * The symbol of the token.
     */
    symbol: string;
    request: TokenTransactionParams & {
        /**
         * The type of the token transaction.
         */
        txType: TokenTransactionType;
    };
};

export type NftTransaction = TransactionPayloads & {
    /**
     * The symbol of the NFT collection.
     */
    symbol: string;
    /**
     * The name of the NFT collection.
     */
    collectionName: string;
    /**
     * The name of the NFT.
     */
    nftName: string;
    /**
     * The storage of the NFT (IPFS hash).
     */
    storage?: string;
    /**
     * The private metadata of the NFT.
     */
    privateMetadata?: string;
    /**
     * The metadata root of the NFT.
     */
    metadataRoot?: string;
    /**
     * The serialized metadata map of the NFT.
     */
    map?: {
        [key: string]: unknown;
    };
    request: NftTransactionParams & {
        /**
         * The type of the NFT transaction.
         */
        txType: NftTransactionType;
    };
};

export type TokenTransactions = {
    /**
     * Array of token transactions.
     */
    txs: Array<TokenTransaction>;
};

export type NftTransactions = {
    /**
     * Array of NFT transactions.
     */
    txs: Array<NftTransaction>;
};

export type ProveTokenTransaction = {
    /**
     * The transaction object.
     */
    tx: TokenTransaction;
    /**
     * The signed data for the transaction.
     */
    signedData: string;
    /**
     * Optional. Whether to broadcast the transaction after proving.
     */
    sendTransaction?: boolean;
};

export type ProveNftTransaction = {
    /**
     * The transaction object.
     */
    tx: NftTransaction;
    /**
     * The signed data for the transaction.
     */
    signedData: string;
    /**
     * Optional. Whether to broadcast the transaction after proving.
     */
    sendTransaction?: boolean;
};

export type ProveTokenTransactions = {
    /**
     * Array of transactions to be proved.
     */
    txs: Array<ProveTokenTransaction>;
};

export type ProveNftTransactions = {
    /**
     * Array of transactions to be proved.
     */
    txs: Array<ProveNftTransaction>;
};

export type TokenState = {
    /**
     * The address of the token contract.
     */
    tokenAddress: string;
    /**
     * The unique identifier of the token.
     */
    tokenId: string;
    /**
     * The address of the admin contract.
     */
    adminContractAddress: string;
    /**
     * The address of the administrator.
     */
    adminAddress: string;
    /**
     * The token balance of the administrator.
     */
    adminTokenBalance: number;
    /**
     * The total supply of the token.
     */
    totalSupply: number;
    /**
     * Indicates if the token contract is paused.
     */
    isPaused: boolean;
    /**
     * The number of decimal places the token uses.
     */
    decimals: number;
    /**
     * The symbol of the token.
     */
    tokenSymbol: string;
    /**
     * The verification key hash of the token contract.
     */
    verificationKeyHash: string;
    /**
     * The URI of the token metadata.
     */
    uri: string;
    /**
     * The version number of the token contract.
     */
    version: number;
    /**
     * The symbol of the admin token.
     */
    adminTokenSymbol: string;
    /**
     * The URI of the admin token metadata.
     */
    adminUri: string;
    /**
     * The verification key hash of the admin contract.
     */
    adminVerificationKeyHash: string;
    adminVersion: number;
};

export type ProofResult = {
    /**
     * Indicates whether the proof generation was successful.
     */
    success?: boolean;
    /**
     * The transaction hash if the proof was successfully applied.
     */
    hash?: string;
    /**
     * Error message if proof generation failed.
     */
    error?: string;
};

export type AirdropTransactionResponse = {
    /**
     * List of token transactions created for the airdrop.
     */
    txs?: Array<TokenTransaction>;
};

/**
 * Optional. List of whitelisted addresses with optional amounts, or a string.
 */
export type Whitelist = Array<{
    /**
     * The whitelisted address.
     */
    address: string;
    /**
     * Optional. The amount allowed to bid.
     */
    amount?: number;
}> | string;

export type ContractInfoRequest = {
    /**
     * The contract address.
     */
    address: string;
    /**
     * Optional. The tokenId.
     */
    tokenId?: string;
};

export type ContractPropertyType = 'name' | 'role' | 'address' | 'tokenId' | 'verificationKey' | 'verificationKeyHash' | 'zkappVersion' | 'bigint' | 'number' | 'field' | 'boolean' | 'ipfs' | 'string' | 'uri' | 'symbol' | 'bondingCurveMintPrice' | 'bondingCurveRedeemPrice';

export type ContractProperty = {
    type: ContractPropertyType;
    value: string;
    presentation?: string;
};

export type ContractInfo = {
    name: ContractProperty & {
        type?: 'name';
    };
    address: ContractProperty & {
        type?: 'address';
    };
    tokenId: ContractProperty & {
        type?: 'tokenId';
    };
    derivedTokenId: ContractProperty & {
        type?: 'tokenId';
    };
    symbol: ContractProperty & {
        type?: 'symbol';
    };
    uri: ContractProperty & {
        type?: 'uri';
    };
    verificationKey: ContractProperty & {
        type?: 'verificationKey';
    };
    verificationKeyHash: ContractProperty & {
        type?: 'verificationKeyHash';
    };
    zkappVersion: ContractProperty & {
        type?: 'zkappVersion';
    };
    [key: string]: ContractProperty | (ContractProperty & {
        type?: 'name';
    }) | (ContractProperty & {
        type?: 'address';
    }) | (ContractProperty & {
        type?: 'tokenId';
    }) | (ContractProperty & {
        type?: 'tokenId';
    }) | (ContractProperty & {
        type?: 'symbol';
    }) | (ContractProperty & {
        type?: 'uri';
    }) | (ContractProperty & {
        type?: 'verificationKey';
    }) | (ContractProperty & {
        type?: 'verificationKeyHash';
    }) | (ContractProperty & {
        type?: 'zkappVersion';
    });
};

export type LaunchNftCollectionData = {
    body: LaunchNftCollectionStandardAdminParams | LaunchNftCollectionAdvancedAdminParams;
    path?: never;
    query?: never;
    url: '/nft/launch';
};

export type LaunchNftCollectionErrors = {
    /**
     * Bad request - invalid input parameters.
     */
    400: ErrorResponse;
    /**
     * Unauthorized - user not authenticated.
     */
    401: ErrorResponse;
    /**
     * Forbidden - user doesn't have permission.
     */
    403: ErrorResponse;
    /**
     * Too many requests.
     */
    429: ErrorResponse;
    /**
     * Internal server error - something went wrong during the request.
     */
    500: ErrorResponse;
    /**
     * Service unavailable - blockchain or other external service is down.
     */
    503: ErrorResponse;
};

export type LaunchNftCollectionError = LaunchNftCollectionErrors[keyof LaunchNftCollectionErrors];

export type LaunchNftCollectionResponses = {
    /**
     * Successful deployment of a new NFT Collection.
     */
    200: NftTransaction;
};

export type LaunchNftCollectionResponse = LaunchNftCollectionResponses[keyof LaunchNftCollectionResponses];

export type LaunchTokenData = {
    body: LaunchTokenStandardAdminParams | LaunchTokenAdvancedAdminParams | LaunchTokenBondingCurveAdminParams;
    path?: never;
    query?: never;
    url: '/token/launch';
};

export type LaunchTokenErrors = {
    /**
     * Bad request - invalid input parameters.
     */
    400: ErrorResponse;
    /**
     * Unauthorized - user not authenticated.
     */
    401: ErrorResponse;
    /**
     * Forbidden - user doesn't have permission.
     */
    403: ErrorResponse;
    /**
     * Too many requests.
     */
    429: ErrorResponse;
    /**
     * Internal server error - something went wrong during the request.
     */
    500: ErrorResponse;
    /**
     * Service unavailable - blockchain or other external service is down.
     */
    503: ErrorResponse;
};

export type LaunchTokenError = LaunchTokenErrors[keyof LaunchTokenErrors];

export type LaunchTokenResponses = {
    /**
     * Successful deployment of a new token.
     */
    200: TokenTransaction;
};

export type LaunchTokenResponse = LaunchTokenResponses[keyof LaunchTokenResponses];

export type GetContractInfoData = {
    body: ContractInfoRequest;
    path?: never;
    query?: never;
    url: '/info/contract';
};

export type GetContractInfoErrors = {
    /**
     * Bad request - invalid input parameters.
     */
    400: ErrorResponse;
    /**
     * Unauthorized - user not authenticated.
     */
    401: ErrorResponse;
    /**
     * Forbidden - user doesn't have permission.
     */
    403: ErrorResponse;
    /**
     * Too many requests.
     */
    429: ErrorResponse;
    /**
     * Internal server error - something went wrong during the request.
     */
    500: ErrorResponse;
    /**
     * Service unavailable - blockchain or other external service is down.
     */
    503: ErrorResponse;
};

export type GetContractInfoError = GetContractInfoErrors[keyof GetContractInfoErrors];

export type GetContractInfoResponses = {
    /**
     * Successful retrieval of contract info for the given contract and his admin contract and other contracts that are related to it.
     */
    200: Array<ContractInfo>;
};

export type GetContractInfoResponse = GetContractInfoResponses[keyof GetContractInfoResponses];

export type GetNftV2InfoData = {
    body: NftRequestParams;
    path?: never;
    query?: never;
    url: '/info/nft-v2';
};

export type GetNftV2InfoErrors = {
    /**
     * Bad request - invalid input parameters.
     */
    400: ErrorResponse;
    /**
     * Unauthorized - user not authenticated.
     */
    401: ErrorResponse;
    /**
     * Forbidden - user doesn't have permission.
     */
    403: ErrorResponse;
    /**
     * Too many requests.
     */
    429: ErrorResponse;
    /**
     * Internal server error - something went wrong during the request.
     */
    500: ErrorResponse;
    /**
     * Service unavailable - blockchain or other external service is down.
     */
    503: ErrorResponse;
};

export type GetNftV2InfoError = GetNftV2InfoErrors[keyof GetNftV2InfoErrors];

export type GetNftV2InfoResponses = {
    /**
     * Successful response
     */
    200: NftRequestAnswer;
};

export type GetNftV2InfoResponse = GetNftV2InfoResponses[keyof GetNftV2InfoResponses];

export type FaucetData = {
    body: FaucetParams;
    path?: never;
    query?: never;
    url: '/faucet';
};

export type FaucetErrors = {
    /**
     * Bad request - invalid input parameters.
     */
    400: ErrorResponse;
    /**
     * Unauthorized - user not authenticated.
     */
    401: ErrorResponse;
    /**
     * Forbidden - user doesn't have permission.
     */
    403: ErrorResponse;
    /**
     * Too many requests.
     */
    429: ErrorResponse;
    /**
     * Internal server error - something went wrong during the request.
     */
    500: ErrorResponse;
    /**
     * Service unavailable - blockchain or other external service is down.
     */
    503: ErrorResponse;
};

export type FaucetError = FaucetErrors[keyof FaucetErrors];

export type FaucetResponses = {
    /**
     * Faucet response
     */
    200: FaucetResponse;
};

export type FaucetResponse2 = FaucetResponses[keyof FaucetResponses];

export type GetTokenInfoData = {
    body: TokenInfoRequestParams;
    path?: never;
    query?: never;
    url: '/info/token';
};

export type GetTokenInfoErrors = {
    /**
     * Bad request - invalid input parameters.
     */
    400: ErrorResponse;
    /**
     * Unauthorized - user not authenticated.
     */
    401: ErrorResponse;
    /**
     * Forbidden - user doesn't have permission.
     */
    403: ErrorResponse;
    /**
     * Too many requests.
     */
    429: ErrorResponse;
    /**
     * Internal server error - something went wrong during the request.
     */
    500: ErrorResponse;
    /**
     * Service unavailable - blockchain or other external service is down.
     */
    503: ErrorResponse;
};

export type GetTokenInfoError = GetTokenInfoErrors[keyof GetTokenInfoErrors];

export type GetTokenInfoResponses = {
    /**
     * Successful retrieval of token information.
     */
    200: TokenState;
};

export type GetTokenInfoResponse = GetTokenInfoResponses[keyof GetTokenInfoResponses];

export type GetTokenBalanceData = {
    body: BalanceRequestParams;
    path?: never;
    query?: never;
    url: '/info/balance';
};

export type GetTokenBalanceErrors = {
    /**
     * Bad request - invalid input parameters.
     */
    400: ErrorResponse;
    /**
     * Unauthorized - user not authenticated.
     */
    401: ErrorResponse;
    /**
     * Forbidden - user doesn't have permission.
     */
    403: ErrorResponse;
    /**
     * Too many requests.
     */
    429: ErrorResponse;
    /**
     * Internal server error - something went wrong during the request.
     */
    500: ErrorResponse;
    /**
     * Service unavailable - blockchain or other external service is down.
     */
    503: ErrorResponse;
};

export type GetTokenBalanceError = GetTokenBalanceErrors[keyof GetTokenBalanceErrors];

export type GetTokenBalanceResponses = {
    /**
     * Successful retrieval of balance.
     */
    200: BalanceResponse;
};

export type GetTokenBalanceResponse = GetTokenBalanceResponses[keyof GetTokenBalanceResponses];

export type ProveData = {
    body: ProveTokenTransaction | ProveTokenTransactions | ProveNftTransaction | ProveNftTransactions;
    path?: never;
    query?: never;
    url: '/transaction/prove';
};

export type ProveErrors = {
    /**
     * Bad request - invalid input parameters.
     */
    400: ErrorResponse;
    /**
     * Unauthorized - user not authenticated.
     */
    401: ErrorResponse;
    /**
     * Forbidden - user doesn't have permission.
     */
    403: ErrorResponse;
    /**
     * Too many requests.
     */
    429: ErrorResponse;
    /**
     * Internal server error - something went wrong during the request.
     */
    500: ErrorResponse;
    /**
     * Service unavailable - blockchain or other external service is down.
     */
    503: ErrorResponse;
};

export type ProveError = ProveErrors[keyof ProveErrors];

export type ProveResponses = {
    /**
     * Successfully initiated proof generation.
     */
    200: JobId;
};

export type ProveResponse = ProveResponses[keyof ProveResponses];

export type GetProofData = {
    body: JobId;
    path?: never;
    query?: never;
    url: '/transaction/proof';
};

export type GetProofErrors = {
    /**
     * Bad request - invalid input parameters.
     */
    400: ErrorResponse;
    /**
     * Unauthorized - user not authenticated.
     */
    401: ErrorResponse;
    /**
     * Forbidden - user doesn't have permission.
     */
    403: ErrorResponse;
    /**
     * Too many requests.
     */
    429: ErrorResponse;
    /**
     * Internal server error - something went wrong during the request.
     */
    500: ErrorResponse;
    /**
     * Service unavailable - blockchain or other external service is down.
     */
    503: ErrorResponse;
};

export type GetProofError = GetProofErrors[keyof GetProofErrors];

export type GetProofResponses = {
    /**
     * Successfully retrieved job status and proofs.
     */
    200: JobResults;
};

export type GetProofResponse = GetProofResponses[keyof GetProofResponses];

export type SendTransactionData = {
    body: SendTransactionParams;
    path?: never;
    query?: never;
    url: '/transaction/send';
};

export type SendTransactionErrors = {
    /**
     * Bad request - invalid input parameters.
     */
    400: ErrorResponse;
    /**
     * Unauthorized - user not authenticated.
     */
    401: ErrorResponse;
    /**
     * Forbidden - user doesn't have permission.
     */
    403: ErrorResponse;
    /**
     * Too many requests.
     */
    429: ErrorResponse;
    /**
     * Internal server error - something went wrong during the request.
     */
    500: ErrorResponse;
    /**
     * Service unavailable - blockchain or other external service is down.
     */
    503: ErrorResponse;
};

export type SendTransactionError = SendTransactionErrors[keyof SendTransactionErrors];

export type SendTransactionResponses = {
    /**
     * Successfully sent transaction.
     */
    200: SendTransactionReply;
};

export type SendTransactionResponse = SendTransactionResponses[keyof SendTransactionResponses];

export type TxStatusData = {
    body: TransactionStatusParams;
    path?: never;
    query?: never;
    url: '/transaction/status';
};

export type TxStatusErrors = {
    /**
     * Bad request - invalid input parameters.
     */
    400: ErrorResponse;
    /**
     * Unauthorized - user not authenticated.
     */
    401: ErrorResponse;
    /**
     * Forbidden - user doesn't have permission.
     */
    403: ErrorResponse;
    /**
     * Too many requests.
     */
    429: ErrorResponse;
    /**
     * Internal server error - something went wrong during the request.
     */
    500: ErrorResponse;
    /**
     * Service unavailable - blockchain or other external service is down.
     */
    503: ErrorResponse;
};

export type TxStatusError = TxStatusErrors[keyof TxStatusErrors];

export type TxStatusResponses = {
    /**
     * Successfully retrieved transaction status.
     */
    200: TransactionStatus;
};

export type TxStatusResponse = TxStatusResponses[keyof TxStatusResponses];

export type MintTokensData = {
    body: TokenMintTransactionParams;
    path?: never;
    query?: never;
    url: '/token/mint';
};

export type MintTokensErrors = {
    /**
     * Bad request - invalid input parameters.
     */
    400: ErrorResponse;
    /**
     * Unauthorized - user not authenticated.
     */
    401: ErrorResponse;
    /**
     * Forbidden - user doesn't have permission.
     */
    403: ErrorResponse;
    /**
     * Too many requests.
     */
    429: ErrorResponse;
    /**
     * Internal server error - something went wrong during the request.
     */
    500: ErrorResponse;
    /**
     * Service unavailable - blockchain or other external service is down.
     */
    503: ErrorResponse;
};

export type MintTokensError = MintTokensErrors[keyof MintTokensErrors];

export type MintTokensResponses = {
    /**
     * Successfully built mint transaction.
     */
    200: TokenTransaction;
};

export type MintTokensResponse = MintTokensResponses[keyof MintTokensResponses];

export type MintNftData = {
    body: NftMintTransactionParams;
    path?: never;
    query?: never;
    url: '/nft/mint';
};

export type MintNftErrors = {
    /**
     * Bad request - invalid input parameters.
     */
    400: ErrorResponse;
    /**
     * Unauthorized - user not authenticated.
     */
    401: ErrorResponse;
    /**
     * Forbidden - user doesn't have permission.
     */
    403: ErrorResponse;
    /**
     * Too many requests.
     */
    429: ErrorResponse;
    /**
     * Internal server error - something went wrong during the request.
     */
    500: ErrorResponse;
    /**
     * Service unavailable - blockchain or other external service is down.
     */
    503: ErrorResponse;
};

export type MintNftError = MintNftErrors[keyof MintNftErrors];

export type MintNftResponses = {
    /**
     * Successfully built mint transaction.
     */
    200: NftTransaction;
};

export type MintNftResponse = MintNftResponses[keyof MintNftResponses];

export type TransferTokensData = {
    body: TokenTransferTransactionParams;
    path?: never;
    query?: never;
    url: '/token/transfer';
};

export type TransferTokensErrors = {
    /**
     * Bad request - invalid input parameters.
     */
    400: ErrorResponse;
    /**
     * Unauthorized - user not authenticated.
     */
    401: ErrorResponse;
    /**
     * Forbidden - user doesn't have permission.
     */
    403: ErrorResponse;
    /**
     * Too many requests.
     */
    429: ErrorResponse;
    /**
     * Internal server error - something went wrong during the request.
     */
    500: ErrorResponse;
    /**
     * Service unavailable - blockchain or other external service is down.
     */
    503: ErrorResponse;
};

export type TransferTokensError = TransferTokensErrors[keyof TransferTokensErrors];

export type TransferTokensResponses = {
    /**
     * Successfully built transfer transaction.
     */
    200: TokenTransaction;
};

export type TransferTokensResponse = TransferTokensResponses[keyof TransferTokensResponses];

export type AirdropTokensData = {
    body: TokenAirdropTransactionParams;
    path?: never;
    query?: never;
    url: '/token/airdrop';
};

export type AirdropTokensErrors = {
    /**
     * Bad request - invalid input parameters.
     */
    400: ErrorResponse;
    /**
     * Unauthorized - user not authenticated.
     */
    401: ErrorResponse;
    /**
     * Forbidden - user doesn't have permission.
     */
    403: ErrorResponse;
    /**
     * Too many requests.
     */
    429: ErrorResponse;
    /**
     * Internal server error - something went wrong during the request.
     */
    500: ErrorResponse;
    /**
     * Service unavailable - blockchain or other external service is down.
     */
    503: ErrorResponse;
};

export type AirdropTokensError = AirdropTokensErrors[keyof AirdropTokensErrors];

export type AirdropTokensResponses = {
    /**
     * Successfully built airdrop transaction.
     */
    200: AirdropTransactionResponse;
};

export type AirdropTokensResponse = AirdropTokensResponses[keyof AirdropTokensResponses];

export type RedeemTokensData = {
    body: TokenRedeemTransactionParams;
    path?: never;
    query?: never;
    url: '/token/redeem';
};

export type RedeemTokensErrors = {
    /**
     * Bad request - invalid input parameters.
     */
    400: ErrorResponse;
    /**
     * Unauthorized - user not authenticated.
     */
    401: ErrorResponse;
    /**
     * Forbidden - user doesn't have permission.
     */
    403: ErrorResponse;
    /**
     * Too many requests.
     */
    429: ErrorResponse;
    /**
     * Internal server error - something went wrong during the request.
     */
    500: ErrorResponse;
    /**
     * Service unavailable - blockchain or other external service is down.
     */
    503: ErrorResponse;
};

export type RedeemTokensError = RedeemTokensErrors[keyof RedeemTokensErrors];

export type RedeemTokensResponses = {
    /**
     * Successfully built redeem transaction.
     */
    200: TokenTransaction;
};

export type RedeemTokensResponse = RedeemTokensResponses[keyof RedeemTokensResponses];

export type BurnTokensData = {
    body: TokenBurnTransactionParams;
    path?: never;
    query?: never;
    url: '/token/burn';
};

export type BurnTokensErrors = {
    /**
     * Bad request - invalid input parameters.
     */
    400: ErrorResponse;
    /**
     * Unauthorized - user not authenticated.
     */
    401: ErrorResponse;
    /**
     * Forbidden - user doesn't have permission.
     */
    403: ErrorResponse;
    /**
     * Too many requests.
     */
    429: ErrorResponse;
    /**
     * Internal server error - something went wrong during the request.
     */
    500: ErrorResponse;
    /**
     * Service unavailable - blockchain or other external service is down.
     */
    503: ErrorResponse;
};

export type BurnTokensError = BurnTokensErrors[keyof BurnTokensErrors];

export type BurnTokensResponses = {
    /**
     * Successfully built burn transaction.
     */
    200: TokenTransaction;
};

export type BurnTokensResponse = BurnTokensResponses[keyof BurnTokensResponses];

export type TokenBidData = {
    body: TokenBidTransactionParams;
    path?: never;
    query?: never;
    url: '/token/bid/create';
};

export type TokenBidErrors = {
    /**
     * Bad request - invalid input parameters.
     */
    400: ErrorResponse;
    /**
     * Unauthorized - user not authenticated.
     */
    401: ErrorResponse;
    /**
     * Forbidden - user doesn't have permission.
     */
    403: ErrorResponse;
    /**
     * Too many requests.
     */
    429: ErrorResponse;
    /**
     * Internal server error - something went wrong during the request.
     */
    500: ErrorResponse;
    /**
     * Service unavailable - blockchain or other external service is down.
     */
    503: ErrorResponse;
};

export type TokenBidError = TokenBidErrors[keyof TokenBidErrors];

export type TokenBidResponses = {
    /**
     * Successfully built bid transaction.
     */
    200: TokenTransaction;
};

export type TokenBidResponse = TokenBidResponses[keyof TokenBidResponses];

export type TokenOfferData = {
    body: TokenOfferTransactionParams;
    path?: never;
    query?: never;
    url: '/token/offer/create';
};

export type TokenOfferErrors = {
    /**
     * Bad request - invalid input parameters.
     */
    400: ErrorResponse;
    /**
     * Unauthorized - user not authenticated.
     */
    401: ErrorResponse;
    /**
     * Forbidden - user doesn't have permission.
     */
    403: ErrorResponse;
    /**
     * Too many requests.
     */
    429: ErrorResponse;
    /**
     * Internal server error - something went wrong during the request.
     */
    500: ErrorResponse;
    /**
     * Service unavailable - blockchain or other external service is down.
     */
    503: ErrorResponse;
};

export type TokenOfferError = TokenOfferErrors[keyof TokenOfferErrors];

export type TokenOfferResponses = {
    /**
     * Successfully created offer transaction.
     */
    200: TokenTransaction;
};

export type TokenOfferResponse = TokenOfferResponses[keyof TokenOfferResponses];

export type BuyTokensData = {
    body: TokenBuyTransactionParams;
    path?: never;
    query?: never;
    url: '/token/offer/buy';
};

export type BuyTokensErrors = {
    /**
     * Bad request - invalid input parameters.
     */
    400: ErrorResponse;
    /**
     * Unauthorized - user not authenticated.
     */
    401: ErrorResponse;
    /**
     * Forbidden - user doesn't have permission.
     */
    403: ErrorResponse;
    /**
     * Too many requests.
     */
    429: ErrorResponse;
    /**
     * Internal server error - something went wrong during the request.
     */
    500: ErrorResponse;
    /**
     * Service unavailable - blockchain or other external service is down.
     */
    503: ErrorResponse;
};

export type BuyTokensError = BuyTokensErrors[keyof BuyTokensErrors];

export type BuyTokensResponses = {
    /**
     * Successfully built buy transaction.
     */
    200: TokenTransaction;
};

export type BuyTokensResponse = BuyTokensResponses[keyof BuyTokensResponses];

export type SellTokensData = {
    body: TokenSellTransactionParams;
    path?: never;
    query?: never;
    url: '/token/bid/sell';
};

export type SellTokensErrors = {
    /**
     * Bad request - invalid input parameters.
     */
    400: ErrorResponse;
    /**
     * Unauthorized - user not authenticated.
     */
    401: ErrorResponse;
    /**
     * Forbidden - user doesn't have permission.
     */
    403: ErrorResponse;
    /**
     * Too many requests.
     */
    429: ErrorResponse;
    /**
     * Internal server error - something went wrong during the request.
     */
    500: ErrorResponse;
    /**
     * Service unavailable - blockchain or other external service is down.
     */
    503: ErrorResponse;
};

export type SellTokensError = SellTokensErrors[keyof SellTokensErrors];

export type SellTokensResponses = {
    /**
     * Successfully built sell transaction.
     */
    200: TokenTransaction;
};

export type SellTokensResponse = SellTokensResponses[keyof SellTokensResponses];

export type WithdrawTokenBidData = {
    body: TokenWithdrawBidTransactionParams;
    path?: never;
    query?: never;
    url: '/token/bid/withdraw';
};

export type WithdrawTokenBidErrors = {
    /**
     * Bad request - invalid input parameters.
     */
    400: ErrorResponse;
    /**
     * Unauthorized - user not authenticated.
     */
    401: ErrorResponse;
    /**
     * Forbidden - user doesn't have permission.
     */
    403: ErrorResponse;
    /**
     * Too many requests.
     */
    429: ErrorResponse;
    /**
     * Internal server error - something went wrong during the request.
     */
    500: ErrorResponse;
    /**
     * Service unavailable - blockchain or other external service is down.
     */
    503: ErrorResponse;
};

export type WithdrawTokenBidError = WithdrawTokenBidErrors[keyof WithdrawTokenBidErrors];

export type WithdrawTokenBidResponses = {
    /**
     * Successfully built withdraw bid transaction.
     */
    200: TokenTransaction;
};

export type WithdrawTokenBidResponse = WithdrawTokenBidResponses[keyof WithdrawTokenBidResponses];

export type WithdrawTokenOfferData = {
    body: TokenWithdrawOfferTransactionParams;
    path?: never;
    query?: never;
    url: '/token/offer/withdraw';
};

export type WithdrawTokenOfferErrors = {
    /**
     * Bad request - invalid input parameters.
     */
    400: ErrorResponse;
    /**
     * Unauthorized - user not authenticated.
     */
    401: ErrorResponse;
    /**
     * Forbidden - user doesn't have permission.
     */
    403: ErrorResponse;
    /**
     * Too many requests.
     */
    429: ErrorResponse;
    /**
     * Internal server error - something went wrong during the request.
     */
    500: ErrorResponse;
    /**
     * Service unavailable - blockchain or other external service is down.
     */
    503: ErrorResponse;
};

export type WithdrawTokenOfferError = WithdrawTokenOfferErrors[keyof WithdrawTokenOfferErrors];

export type WithdrawTokenOfferResponses = {
    /**
     * Successfully built withdraw offer transaction.
     */
    200: TokenTransaction;
};

export type WithdrawTokenOfferResponse = WithdrawTokenOfferResponses[keyof WithdrawTokenOfferResponses];

export type UpdateTokenBidWhitelistData = {
    body: TokenUpdateBidWhitelistTransactionParams;
    path?: never;
    query?: never;
    url: '/token/bid/whitelist';
};

export type UpdateTokenBidWhitelistErrors = {
    /**
     * Bad request - invalid input parameters.
     */
    400: ErrorResponse;
    /**
     * Unauthorized - user not authenticated.
     */
    401: ErrorResponse;
    /**
     * Forbidden - user doesn't have permission.
     */
    403: ErrorResponse;
    /**
     * Too many requests.
     */
    429: ErrorResponse;
    /**
     * Internal server error - something went wrong during the request.
     */
    500: ErrorResponse;
    /**
     * Service unavailable - blockchain or other external service is down.
     */
    503: ErrorResponse;
};

export type UpdateTokenBidWhitelistError = UpdateTokenBidWhitelistErrors[keyof UpdateTokenBidWhitelistErrors];

export type UpdateTokenBidWhitelistResponses = {
    /**
     * Successfully built update bid whitelist transaction.
     */
    200: TokenTransaction;
};

export type UpdateTokenBidWhitelistResponse = UpdateTokenBidWhitelistResponses[keyof UpdateTokenBidWhitelistResponses];

export type UpdateTokenOfferWhitelistData = {
    body: TokenUpdateOfferWhitelistTransactionParams;
    path?: never;
    query?: never;
    url: '/token/offer/whitelist';
};

export type UpdateTokenOfferWhitelistErrors = {
    /**
     * Bad request - invalid input parameters.
     */
    400: ErrorResponse;
    /**
     * Unauthorized - user not authenticated.
     */
    401: ErrorResponse;
    /**
     * Forbidden - user doesn't have permission.
     */
    403: ErrorResponse;
    /**
     * Too many requests.
     */
    429: ErrorResponse;
    /**
     * Internal server error - something went wrong during the request.
     */
    500: ErrorResponse;
    /**
     * Service unavailable - blockchain or other external service is down.
     */
    503: ErrorResponse;
};

export type UpdateTokenOfferWhitelistError = UpdateTokenOfferWhitelistErrors[keyof UpdateTokenOfferWhitelistErrors];

export type UpdateTokenOfferWhitelistResponses = {
    /**
     * Successfully built update offer whitelist transaction.
     */
    200: TokenTransaction;
};

export type UpdateTokenOfferWhitelistResponse = UpdateTokenOfferWhitelistResponses[keyof UpdateTokenOfferWhitelistResponses];

export type UpdateTokenAdminWhitelistData = {
    body: TokenUpdateAdminWhitelistTransactionParams;
    path?: never;
    query?: never;
    url: '/token/admin/whitelist';
};

export type UpdateTokenAdminWhitelistErrors = {
    /**
     * Bad request - invalid input parameters.
     */
    400: ErrorResponse;
    /**
     * Unauthorized - user not authenticated.
     */
    401: ErrorResponse;
    /**
     * Forbidden - user doesn't have permission.
     */
    403: ErrorResponse;
    /**
     * Too many requests.
     */
    429: ErrorResponse;
    /**
     * Internal server error - something went wrong during the request.
     */
    500: ErrorResponse;
    /**
     * Service unavailable - blockchain or other external service is down.
     */
    503: ErrorResponse;
};

export type UpdateTokenAdminWhitelistError = UpdateTokenAdminWhitelistErrors[keyof UpdateTokenAdminWhitelistErrors];

export type UpdateTokenAdminWhitelistResponses = {
    /**
     * Successfully built update admin whitelist transaction.
     */
    200: TokenTransaction;
};

export type UpdateTokenAdminWhitelistResponse = UpdateTokenAdminWhitelistResponses[keyof UpdateTokenAdminWhitelistResponses];

export type ClientOptions = {
    baseUrl: 'https://minatokens.com/api/v1/' | 'https://devnet.minatokens.com/api/v1/' | 'https://zekotokens.com/api/v1/' | (string & {});
};